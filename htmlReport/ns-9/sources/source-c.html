


<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8"> 
  <title>Coverage Report > StakeServiceImpl</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">com.wallet.biochain.services.impl</a>
</div>

<h1>Coverage Summary for Class: StakeServiceImpl (com.wallet.biochain.services.impl)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Branch, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">StakeServiceImpl</td>
<td class="coverageStat">
  <span class="percent">
    61,5%
  </span>
  <span class="absValue">
    (8/13)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    77,8%
  </span>
  <span class="absValue">
    (28/36)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    83,8%
  </span>
  <span class="absValue">
    (93/111)
  </span>
</td>
</tr>
  <tr>
    <td class="name">StakeServiceImpl$$SpringCGLIB$$0</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    61,5%
  </span>
  <span class="absValue">
    (8/13)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    77,8%
  </span>
  <span class="absValue">
    (28/36)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    83,8%
  </span>
  <span class="absValue">
    (93/111)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;package com.wallet.biochain.services.impl;
&nbsp;
&nbsp;import com.wallet.biochain.config.BlockchainConfig;
&nbsp;import com.wallet.biochain.dto.StakeDTO;
&nbsp;import com.wallet.biochain.entities.Stake;
&nbsp;import com.wallet.biochain.entities.User;
&nbsp;import com.wallet.biochain.entities.Wallet;
&nbsp;import com.wallet.biochain.enums.StakeStatus;
&nbsp;import com.wallet.biochain.mappers.StakeMapper;
&nbsp;import com.wallet.biochain.repositories.StakeRepository;
&nbsp;import com.wallet.biochain.repositories.UserRepository;
&nbsp;import com.wallet.biochain.repositories.WalletRepository;
&nbsp;import com.wallet.biochain.services.PoSConsensusService;
&nbsp;import com.wallet.biochain.services.StakeService;
&nbsp;import lombok.RequiredArgsConstructor;
&nbsp;import lombok.extern.slf4j.Slf4j;
&nbsp;import org.springframework.messaging.simp.SimpMessagingTemplate;
&nbsp;import org.springframework.stereotype.Service;
&nbsp;import org.springframework.transaction.annotation.Transactional;
&nbsp;
&nbsp;import java.math.BigDecimal;
&nbsp;import java.time.LocalDateTime;
&nbsp;import java.util.List;
&nbsp;import java.util.Optional;
&nbsp;
<b class="fc">&nbsp;@Slf4j</b>
&nbsp;@Service
&nbsp;@RequiredArgsConstructor
&nbsp;public class StakeServiceImpl implements StakeService {
&nbsp;
&nbsp;    private final StakeRepository stakeRepository;
&nbsp;    private final UserRepository userRepository;
&nbsp;    private final WalletRepository walletRepository;
&nbsp;    private final PoSConsensusService posConsensusService;
&nbsp;    private final StakeMapper stakeMapper;
&nbsp;    private final BlockchainConfig blockchainConfig;
&nbsp;    private final SimpMessagingTemplate messagingTemplate;
&nbsp;
&nbsp;    @Override
&nbsp;    @Transactional
&nbsp;    public StakeDTO createStake(Long userId, String walletAddress, BigDecimal amount, LocalDateTime lockedUntil) {
<b class="fc">&nbsp;        log.info(&quot;Creating stake for user {} with amount {}&quot;, userId, amount);</b>
&nbsp;
&nbsp;        // Validate minimum stake amount
<b class="fc">&nbsp;        BigDecimal minStake = blockchainConfig.getConsensus().getMinStakeAmount();</b>
<b class="fc">&nbsp;        if (amount.compareTo(minStake) &lt; 0) {</b>
<b class="fc">&nbsp;            throw new IllegalArgumentException(&quot;Stake amount must be at least &quot; + minStake);</b>
&nbsp;        }
&nbsp;
&nbsp;        // Validate user exists
<b class="fc">&nbsp;        User user = userRepository.findById(userId)</b>
<b class="fc">&nbsp;                .orElseThrow(() -&gt; new IllegalArgumentException(&quot;User not found with ID: &quot; + userId));</b>
&nbsp;
&nbsp;        // Validate wallet exists and belongs to user
<b class="fc">&nbsp;        Wallet wallet = walletRepository.findByAddress(walletAddress)</b>
<b class="fc">&nbsp;                .orElseThrow(() -&gt; new IllegalArgumentException(&quot;Wallet not found: &quot; + walletAddress));</b>
&nbsp;
<b class="fc">&nbsp;        if (!wallet.getUser().getId().equals(userId)) {</b>
<b class="fc">&nbsp;            throw new IllegalArgumentException(&quot;Wallet does not belong to user&quot;);</b>
&nbsp;        }
&nbsp;
&nbsp;        // Validate sufficient balance
<b class="fc">&nbsp;        if (wallet.getBalance().compareTo(amount) &lt; 0) {</b>
<b class="fc">&nbsp;            throw new IllegalStateException(&quot;Insufficient balance for staking. Required: &quot; + amount +</b>
<b class="fc">&nbsp;                    &quot;, Available: &quot; + wallet.getBalance());</b>
&nbsp;        }
&nbsp;
&nbsp;        // Validate lock period
<b class="pc">&nbsp;        if (lockedUntil != null &amp;&amp; lockedUntil.isBefore(LocalDateTime.now())) {</b>
<b class="nc">&nbsp;            throw new IllegalArgumentException(&quot;Lock until date must be in the future&quot;);</b>
&nbsp;        }
&nbsp;
&nbsp;        // Create stake
<b class="fc">&nbsp;        Stake stake = new Stake(user, walletAddress, amount, lockedUntil);</b>
<b class="fc">&nbsp;        if (lockedUntil != null) {</b>
<b class="fc">&nbsp;            stake.setStatus(StakeStatus.LOCKED);</b>
&nbsp;        } else {
<b class="fc">&nbsp;            stake.setStatus(StakeStatus.ACTIVE);</b>
&nbsp;        }
&nbsp;
&nbsp;        // Deduct from wallet balance
<b class="fc">&nbsp;        wallet.setBalance(wallet.getBalance().subtract(amount));</b>
<b class="fc">&nbsp;        walletRepository.save(wallet);</b>
&nbsp;
<b class="fc">&nbsp;        Stake savedStake = stakeRepository.save(stake);</b>
<b class="fc">&nbsp;        log.info(&quot;Stake created successfully with ID: {}&quot;, savedStake.getId());</b>
&nbsp;
&nbsp;        // Broadcast stake event via WebSocket
&nbsp;        try {
<b class="fc">&nbsp;            StakeDTO stakeDTO = stakeMapper.toDTO(savedStake);</b>
<b class="fc">&nbsp;            messagingTemplate.convertAndSend(&quot;/topic/stakes&quot;, stakeDTO);</b>
&nbsp;        } catch (Exception e) {
<b class="nc">&nbsp;            log.error(&quot;Failed to broadcast stake creation event&quot;, e);</b>
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        return stakeMapper.toDTO(savedStake);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    @Transactional(readOnly = true)
&nbsp;    public Optional&lt;StakeDTO&gt; getStakeById(Long id) {
<b class="nc">&nbsp;        log.debug(&quot;Fetching stake by ID: {}&quot;, id);</b>
<b class="nc">&nbsp;        return stakeRepository.findById(id).map(stakeMapper::toDTO);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    @Transactional(readOnly = true)
&nbsp;    public List&lt;StakeDTO&gt; getStakesByUserId(Long userId) {
<b class="nc">&nbsp;        log.debug(&quot;Fetching stakes for user ID: {}&quot;, userId);</b>
<b class="nc">&nbsp;        return stakeMapper.toDTOList(stakeRepository.findByUserId(userId));</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    @Transactional(readOnly = true)
&nbsp;    public List&lt;StakeDTO&gt; getStakesByWalletAddress(String walletAddress) {
<b class="nc">&nbsp;        log.debug(&quot;Fetching stakes for wallet: {}&quot;, walletAddress);</b>
<b class="nc">&nbsp;        return stakeMapper.toDTOList(stakeRepository.findByWalletAddress(walletAddress));</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    @Transactional(readOnly = true)
&nbsp;    public List&lt;StakeDTO&gt; getActiveStakes() {
<b class="nc">&nbsp;        log.debug(&quot;Fetching all active stakes&quot;);</b>
<b class="nc">&nbsp;        return stakeMapper.toDTOList(stakeRepository.findActiveStakes());</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    @Transactional
&nbsp;    public void unlockExpiredStakes() {
<b class="fc">&nbsp;        log.info(&quot;Unlocking expired stakes&quot;);</b>
&nbsp;
<b class="fc">&nbsp;        LocalDateTime now = LocalDateTime.now();</b>
<b class="fc">&nbsp;        List&lt;Stake&gt; expiredStakes = stakeRepository.findExpiredLocks(now);</b>
&nbsp;
<b class="fc">&nbsp;        int unlockedCount = 0;</b>
<b class="fc">&nbsp;        for (Stake stake : expiredStakes) {</b>
<b class="pc">&nbsp;            if (stake.getStatus() == StakeStatus.LOCKED) {</b>
<b class="fc">&nbsp;                stake.setStatus(StakeStatus.UNLOCKED);</b>
<b class="fc">&nbsp;                stakeRepository.save(stake);</b>
<b class="fc">&nbsp;                unlockedCount++;</b>
&nbsp;
<b class="fc">&nbsp;                log.debug(&quot;Unlocked stake ID: {}&quot;, stake.getId());</b>
&nbsp;
&nbsp;                // Broadcast unlock event
&nbsp;                try {
<b class="fc">&nbsp;                    messagingTemplate.convertAndSend(&quot;/topic/stakes/unlocked&quot;,</b>
<b class="fc">&nbsp;                            stakeMapper.toDTO(stake));</b>
&nbsp;                } catch (Exception e) {
<b class="nc">&nbsp;                    log.error(&quot;Failed to broadcast unlock event&quot;, e);</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        log.info(&quot;Unlocked {} expired stakes&quot;, unlockedCount);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    @Transactional
&nbsp;    public void withdrawStake(Long stakeId) {
<b class="fc">&nbsp;        log.info(&quot;Withdrawing stake: {}&quot;, stakeId);</b>
&nbsp;
<b class="fc">&nbsp;        Stake stake = stakeRepository.findById(stakeId)</b>
<b class="fc">&nbsp;                .orElseThrow(() -&gt; new IllegalArgumentException(&quot;Stake not found with ID: &quot; + stakeId));</b>
&nbsp;
&nbsp;        // Check if stake is locked
<b class="fc">&nbsp;        if (stake.isLocked()) {</b>
<b class="fc">&nbsp;            throw new IllegalStateException(&quot;Cannot withdraw locked stake. Lock expires at: &quot; +</b>
<b class="fc">&nbsp;                    stake.getLockedUntil());</b>
&nbsp;        }
&nbsp;
&nbsp;        // Check if already withdrawn
<b class="fc">&nbsp;        if (stake.getStatus() == StakeStatus.WITHDRAWN) {</b>
<b class="fc">&nbsp;            throw new IllegalStateException(&quot;Stake has already been withdrawn&quot;);</b>
&nbsp;        }
&nbsp;
&nbsp;        // Calculate total amount to return (staked amount + rewards)
<b class="pc">&nbsp;        BigDecimal stakedAmount = stake.getStakedAmount() != null ? stake.getStakedAmount() : BigDecimal.ZERO;</b>
<b class="pc">&nbsp;        BigDecimal rewards = stake.getRewardsEarned() != null ? stake.getRewardsEarned() : BigDecimal.ZERO;</b>
<b class="fc">&nbsp;        BigDecimal totalReturn = stakedAmount.add(rewards);</b>
&nbsp;
&nbsp;        // Return to wallet
<b class="fc">&nbsp;        Wallet wallet = walletRepository.findByAddress(stake.getWalletAddress())</b>
<b class="fc">&nbsp;                .orElseThrow(() -&gt; new IllegalArgumentException(&quot;Wallet not found: &quot; + stake.getWalletAddress()));</b>
&nbsp;
<b class="fc">&nbsp;        wallet.setBalance(wallet.getBalance().add(totalReturn));</b>
<b class="fc">&nbsp;        walletRepository.save(wallet);</b>
&nbsp;
&nbsp;        // Mark stake as withdrawn
<b class="fc">&nbsp;        stake.setStatus(StakeStatus.WITHDRAWN);</b>
<b class="fc">&nbsp;        stakeRepository.save(stake);</b>
&nbsp;
<b class="fc">&nbsp;        log.info(&quot;Stake withdrawn successfully. Amount returned: {}&quot;, totalReturn);</b>
&nbsp;
&nbsp;        // Broadcast withdrawal event
&nbsp;        try {
<b class="fc">&nbsp;            messagingTemplate.convertAndSend(&quot;/topic/stakes/withdrawn&quot;, stakeMapper.toDTO(stake));</b>
&nbsp;        } catch (Exception e) {
<b class="nc">&nbsp;            log.error(&quot;Failed to broadcast withdrawal event&quot;, e);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    @Transactional(readOnly = true)
&nbsp;    public BigDecimal calculateRewards(Long stakeId) {
<b class="fc">&nbsp;        log.debug(&quot;Calculating rewards for stake: {}&quot;, stakeId);</b>
&nbsp;
<b class="fc">&nbsp;        Stake stake = stakeRepository.findById(stakeId)</b>
<b class="fc">&nbsp;                .orElseThrow(() -&gt; new IllegalArgumentException(&quot;Stake not found with ID: &quot; + stakeId));</b>
&nbsp;
<b class="fc">&nbsp;        BigDecimal reward = posConsensusService.calculateStakingReward(stake);</b>
<b class="fc">&nbsp;        log.debug(&quot;Calculated reward: {} for stake: {}&quot;, reward, stakeId);</b>
&nbsp;
<b class="fc">&nbsp;        return reward;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    @Transactional
&nbsp;    public void distributeRewards() {
<b class="fc">&nbsp;        log.info(&quot;Distributing staking rewards&quot;);</b>
&nbsp;
<b class="fc">&nbsp;        List&lt;Stake&gt; activeStakes = stakeRepository.findActiveStakes();</b>
&nbsp;
<b class="fc">&nbsp;        if (activeStakes.isEmpty()) {</b>
<b class="fc">&nbsp;            log.info(&quot;No active stakes to distribute rewards to&quot;);</b>
&nbsp;            return;
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        BigDecimal totalRewardsDistributed = BigDecimal.ZERO;</b>
<b class="fc">&nbsp;        int successCount = 0;</b>
<b class="fc">&nbsp;        int failCount = 0;</b>
&nbsp;
<b class="fc">&nbsp;        for (Stake stake : activeStakes) {</b>
&nbsp;            try {
&nbsp;                // Calculate reward for this stake
<b class="fc">&nbsp;                BigDecimal reward = posConsensusService.calculateStakingReward(stake);</b>
&nbsp;
<b class="pc">&nbsp;                if (reward.compareTo(BigDecimal.ZERO) &gt; 0) {</b>
&nbsp;                    // Add reward to stake
<b class="pc">&nbsp;                    BigDecimal currentRewards = stake.getRewardsEarned() != null ?</b>
<b class="fc">&nbsp;                            stake.getRewardsEarned() : BigDecimal.ZERO;</b>
<b class="fc">&nbsp;                    stake.setRewardsEarned(currentRewards.add(reward));</b>
<b class="fc">&nbsp;                    stake.setLastRewardTime(LocalDateTime.now());</b>
&nbsp;
<b class="fc">&nbsp;                    stakeRepository.save(stake);</b>
&nbsp;
<b class="fc">&nbsp;                    totalRewardsDistributed = totalRewardsDistributed.add(reward);</b>
<b class="fc">&nbsp;                    successCount++;</b>
&nbsp;
<b class="fc">&nbsp;                    log.debug(&quot;Distributed reward {} to stake {}&quot;, reward, stake.getId());</b>
&nbsp;                }
&nbsp;            } catch (Exception e) {
<b class="nc">&nbsp;                log.error(&quot;Failed to distribute reward to stake: {}&quot;, stake.getId(), e);</b>
<b class="nc">&nbsp;                failCount++;</b>
&nbsp;            }
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        log.info(&quot;Reward distribution completed. Total distributed: {}, Success: {}, Failed: {}&quot;,</b>
<b class="fc">&nbsp;                totalRewardsDistributed, successCount, failCount);</b>
&nbsp;
&nbsp;        // Broadcast reward distribution summary
&nbsp;        try {
<b class="fc">&nbsp;            String message = String.format(&quot;Distributed %s rewards to %d stakes&quot;,</b>
<b class="fc">&nbsp;                    totalRewardsDistributed, successCount);</b>
<b class="fc">&nbsp;            messagingTemplate.convertAndSend(&quot;/topic/stakes/rewards&quot;, message);</b>
&nbsp;        } catch (Exception e) {
<b class="nc">&nbsp;            log.error(&quot;Failed to broadcast reward distribution&quot;, e);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    @Transactional(readOnly = true)
&nbsp;    public BigDecimal getTotalStakedAmount() {
<b class="fc">&nbsp;        log.debug(&quot;Calculating total staked amount&quot;);</b>
<b class="fc">&nbsp;        BigDecimal total = stakeRepository.getTotalStakedAmount();</b>
<b class="fc">&nbsp;        return total != null ? total : BigDecimal.ZERO;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    @Transactional(readOnly = true)
&nbsp;    public BigDecimal getTotalStakedAmountByAddress(String walletAddress) {
<b class="nc">&nbsp;        log.debug(&quot;Calculating total staked amount for wallet: {}&quot;, walletAddress);</b>
<b class="nc">&nbsp;        BigDecimal total = stakeRepository.getTotalStakedAmountByAddress(walletAddress);</b>
<b class="nc">&nbsp;        return total != null ? total : BigDecimal.ZERO;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    @Transactional(readOnly = true)
&nbsp;    public List&lt;StakeDTO&gt; getTopStakers() {
<b class="fc">&nbsp;        log.debug(&quot;Fetching top stakers&quot;);</b>
<b class="fc">&nbsp;        List&lt;Stake&gt; topStakes = stakeRepository.findTopStakers();</b>
<b class="fc">&nbsp;        return stakeMapper.toDTOList(topStakes.stream().limit(10).toList());</b>
&nbsp;    }
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2025-12-25 22:18</div>
</div>
</body>
</html>
