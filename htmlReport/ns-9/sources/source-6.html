


<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8"> 
  <title>Coverage Report > CryptographyServiceImpl</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">com.wallet.biochain.services.impl</a>
</div>

<h1>Coverage Summary for Class: CryptographyServiceImpl (com.wallet.biochain.services.impl)</h1>

<table class="coverageStats">
<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Class, %
</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Branch, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">CryptographyServiceImpl</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    94,4%
  </span>
  <span class="absValue">
    (17/18)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    76,6%
  </span>
  <span class="absValue">
    (85/111)
  </span>
</td>
</tr>

</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;package com.wallet.biochain.services.impl;
&nbsp;
&nbsp;import com.wallet.biochain.services.CryptographyService;
&nbsp;import lombok.extern.slf4j.Slf4j;
&nbsp;import org.bouncycastle.jce.provider.BouncyCastleProvider;
&nbsp;import org.springframework.stereotype.Service;
&nbsp;
&nbsp;import javax.crypto.Cipher;
&nbsp;import javax.crypto.SecretKey;
&nbsp;import javax.crypto.SecretKeyFactory;
&nbsp;import javax.crypto.spec.IvParameterSpec;
&nbsp;import javax.crypto.spec.PBEKeySpec;
&nbsp;import javax.crypto.spec.SecretKeySpec;
&nbsp;import java.nio.ByteBuffer;
&nbsp;import java.nio.charset.StandardCharsets;
&nbsp;import java.security.*;
&nbsp;import java.security.spec.PKCS8EncodedKeySpec;
&nbsp;import java.security.spec.X509EncodedKeySpec;
&nbsp;import java.util.Base64;
&nbsp;
<b class="fc">&nbsp;@Slf4j</b>
&nbsp;@Service
<b class="fc">&nbsp;public class CryptographyServiceImpl implements CryptographyService {</b>
&nbsp;
&nbsp;    private static final String RSA_ALGORITHM = &quot;RSA/ECB/OAEPWithSHA-256AndMGF1Padding&quot;;
&nbsp;    private static final String AES_ALGORITHM = &quot;AES/CBC/PKCS5Padding&quot;;
&nbsp;    private static final String SHA_256 = &quot;SHA-256&quot;;
&nbsp;    private static final String SIGNATURE_ALGORITHM = &quot;SHA256withRSA&quot;;
&nbsp;    private static final int KEY_SIZE = 2048;
&nbsp;    private static final int AES_KEY_SIZE = 256;
&nbsp;    private static final int ITERATION_COUNT = 65536;
&nbsp;    private static final int SALT_LENGTH = 32; // 256 bits
&nbsp;    private static final int IV_LENGTH = 16; // 128 bits for AES
&nbsp;
&nbsp;    static {
<b class="fc">&nbsp;        Security.addProvider(new BouncyCastleProvider());</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public KeyPair generateKeyPair() {
&nbsp;        try {
<b class="fc">&nbsp;            KeyPairGenerator keyGen = KeyPairGenerator.getInstance(&quot;RSA&quot;);</b>
<b class="fc">&nbsp;            keyGen.initialize(KEY_SIZE, new SecureRandom());</b>
<b class="fc">&nbsp;            KeyPair keyPair = keyGen.generateKeyPair();</b>
<b class="fc">&nbsp;            log.info(&quot;Generated RSA key pair successfully&quot;);</b>
<b class="fc">&nbsp;            return keyPair;</b>
&nbsp;        } catch (Exception e) {
<b class="nc">&nbsp;            log.error(&quot;Failed to generate key pair&quot;, e);</b>
<b class="nc">&nbsp;            throw new RuntimeException(&quot;Failed to generate key pair&quot;, e);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public String generateAddress(String publicKey) {
&nbsp;        try {
&nbsp;            // Hash the public key with SHA-256
<b class="nc">&nbsp;            String hash = hash(publicKey);</b>
&nbsp;            // Take first 40 characters and prepend &quot;0x&quot; for blockchain-style address
<b class="nc">&nbsp;            String address = &quot;0x&quot; + hash.substring(0, 40);</b>
<b class="nc">&nbsp;            log.debug(&quot;Generated address: {}&quot;, address);</b>
<b class="nc">&nbsp;            return address;</b>
&nbsp;        } catch (Exception e) {
<b class="nc">&nbsp;            log.error(&quot;Failed to generate address&quot;, e);</b>
<b class="nc">&nbsp;            throw new RuntimeException(&quot;Failed to generate address&quot;, e);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public String encrypt(String data, String publicKey) {
&nbsp;        try {
<b class="fc">&nbsp;            PublicKey key = decodePublicKey(publicKey);</b>
<b class="fc">&nbsp;            Cipher cipher = Cipher.getInstance(RSA_ALGORITHM);</b>
<b class="fc">&nbsp;            cipher.init(Cipher.ENCRYPT_MODE, key);</b>
<b class="fc">&nbsp;            byte[] encryptedBytes = cipher.doFinal(data.getBytes(StandardCharsets.UTF_8));</b>
<b class="fc">&nbsp;            return Base64.getEncoder().encodeToString(encryptedBytes);</b>
&nbsp;        } catch (Exception e) {
<b class="nc">&nbsp;            log.error(&quot;Failed to encrypt data&quot;, e);</b>
<b class="nc">&nbsp;            throw new RuntimeException(&quot;Failed to encrypt data&quot;, e);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public String decrypt(String encryptedData, String privateKey) {
&nbsp;        try {
<b class="fc">&nbsp;            PrivateKey key = decodePrivateKey(privateKey);</b>
<b class="fc">&nbsp;            Cipher cipher = Cipher.getInstance(RSA_ALGORITHM);</b>
<b class="fc">&nbsp;            cipher.init(Cipher.DECRYPT_MODE, key);</b>
<b class="fc">&nbsp;            byte[] decryptedBytes = cipher.doFinal(Base64.getDecoder().decode(encryptedData));</b>
<b class="fc">&nbsp;            return new String(decryptedBytes, StandardCharsets.UTF_8);</b>
&nbsp;        } catch (Exception e) {
<b class="nc">&nbsp;            log.error(&quot;Failed to decrypt data&quot;, e);</b>
<b class="nc">&nbsp;            throw new RuntimeException(&quot;Failed to decrypt data&quot;, e);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public String hash(String data) {
&nbsp;        try {
<b class="fc">&nbsp;            MessageDigest digest = MessageDigest.getInstance(SHA_256);</b>
<b class="fc">&nbsp;            byte[] hashBytes = digest.digest(data.getBytes(StandardCharsets.UTF_8));</b>
<b class="fc">&nbsp;            return bytesToHex(hashBytes);</b>
&nbsp;        } catch (Exception e) {
<b class="nc">&nbsp;            log.error(&quot;Failed to hash data&quot;, e);</b>
<b class="nc">&nbsp;            throw new RuntimeException(&quot;Failed to hash data&quot;, e);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public String sign(String data, String privateKey) {
&nbsp;        try {
<b class="fc">&nbsp;            PrivateKey key = decodePrivateKey(privateKey);</b>
<b class="fc">&nbsp;            Signature signature = Signature.getInstance(SIGNATURE_ALGORITHM);</b>
<b class="fc">&nbsp;            signature.initSign(key);</b>
<b class="fc">&nbsp;            signature.update(data.getBytes(StandardCharsets.UTF_8));</b>
<b class="fc">&nbsp;            byte[] signatureBytes = signature.sign();</b>
<b class="fc">&nbsp;            return Base64.getEncoder().encodeToString(signatureBytes);</b>
&nbsp;        } catch (Exception e) {
<b class="nc">&nbsp;            log.error(&quot;Failed to sign data&quot;, e);</b>
<b class="nc">&nbsp;            throw new RuntimeException(&quot;Failed to sign data&quot;, e);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public boolean verifySignature(String data, String signatureStr, String publicKey) {
&nbsp;        try {
<b class="fc">&nbsp;            PublicKey key = decodePublicKey(publicKey);</b>
<b class="fc">&nbsp;            Signature signature = Signature.getInstance(SIGNATURE_ALGORITHM);</b>
<b class="fc">&nbsp;            signature.initVerify(key);</b>
<b class="fc">&nbsp;            signature.update(data.getBytes(StandardCharsets.UTF_8));</b>
<b class="fc">&nbsp;            byte[] signatureBytes = Base64.getDecoder().decode(signatureStr);</b>
<b class="fc">&nbsp;            return signature.verify(signatureBytes);</b>
&nbsp;        } catch (Exception e) {
<b class="nc">&nbsp;            log.error(&quot;Failed to verify signature&quot;, e);</b>
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public String encodePublicKey(PublicKey publicKey) {
<b class="fc">&nbsp;        byte[] encoded = publicKey.getEncoded();</b>
<b class="fc">&nbsp;        return Base64.getEncoder().encodeToString(encoded);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public String encodePrivateKey(PrivateKey privateKey) {
<b class="fc">&nbsp;        byte[] encoded = privateKey.getEncoded();</b>
<b class="fc">&nbsp;        return Base64.getEncoder().encodeToString(encoded);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public PublicKey decodePublicKey(String publicKeyString) {
&nbsp;        try {
<b class="fc">&nbsp;            byte[] decoded = Base64.getDecoder().decode(publicKeyString);</b>
<b class="fc">&nbsp;            X509EncodedKeySpec spec = new X509EncodedKeySpec(decoded);</b>
<b class="fc">&nbsp;            KeyFactory keyFactory = KeyFactory.getInstance(&quot;RSA&quot;);</b>
<b class="fc">&nbsp;            return keyFactory.generatePublic(spec);</b>
&nbsp;        } catch (Exception e) {
<b class="nc">&nbsp;            log.error(&quot;Failed to decode public key&quot;, e);</b>
<b class="nc">&nbsp;            throw new RuntimeException(&quot;Failed to decode public key&quot;, e);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public PrivateKey decodePrivateKey(String privateKeyString) {
&nbsp;        try {
<b class="fc">&nbsp;            byte[] decoded = Base64.getDecoder().decode(privateKeyString);</b>
<b class="fc">&nbsp;            PKCS8EncodedKeySpec spec = new PKCS8EncodedKeySpec(decoded);</b>
<b class="fc">&nbsp;            KeyFactory keyFactory = KeyFactory.getInstance(&quot;RSA&quot;);</b>
<b class="fc">&nbsp;            return keyFactory.generatePrivate(spec);</b>
&nbsp;        } catch (Exception e) {
<b class="nc">&nbsp;            log.error(&quot;Failed to decode private key&quot;, e);</b>
<b class="nc">&nbsp;            throw new RuntimeException(&quot;Failed to decode private key&quot;, e);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public String encryptPrivateKey(String privateKey, String password) {
&nbsp;        try {
&nbsp;            // Generate random salt and IV
<b class="fc">&nbsp;            byte[] salt = generateRandomBytes(SALT_LENGTH);</b>
<b class="fc">&nbsp;            byte[] iv = generateRandomBytes(IV_LENGTH);</b>
&nbsp;
<b class="fc">&nbsp;            SecretKey secretKey = deriveKeyFromPassword(password, salt);</b>
<b class="fc">&nbsp;            Cipher cipher = Cipher.getInstance(AES_ALGORITHM);</b>
<b class="fc">&nbsp;            cipher.init(Cipher.ENCRYPT_MODE, secretKey, new IvParameterSpec(iv));</b>
<b class="fc">&nbsp;            byte[] encryptedBytes = cipher.doFinal(privateKey.getBytes(StandardCharsets.UTF_8));</b>
&nbsp;
&nbsp;            // Combine salt + IV + encrypted data
<b class="fc">&nbsp;            ByteBuffer buffer = ByteBuffer.allocate(salt.length + iv.length + encryptedBytes.length);</b>
<b class="fc">&nbsp;            buffer.put(salt);</b>
<b class="fc">&nbsp;            buffer.put(iv);</b>
<b class="fc">&nbsp;            buffer.put(encryptedBytes);</b>
&nbsp;
<b class="fc">&nbsp;            return Base64.getEncoder().encodeToString(buffer.array());</b>
&nbsp;        } catch (Exception e) {
<b class="nc">&nbsp;            log.error(&quot;Failed to encrypt private key with password&quot;, e);</b>
<b class="nc">&nbsp;            throw new RuntimeException(&quot;Failed to encrypt private key&quot;, e);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public String decryptPrivateKey(String encryptedPrivateKey, String password) {
&nbsp;        try {
<b class="fc">&nbsp;            byte[] combined = Base64.getDecoder().decode(encryptedPrivateKey);</b>
<b class="fc">&nbsp;            ByteBuffer buffer = ByteBuffer.wrap(combined);</b>
&nbsp;
&nbsp;            // Extract salt, IV, and encrypted data
<b class="fc">&nbsp;            byte[] salt = new byte[SALT_LENGTH];</b>
<b class="fc">&nbsp;            byte[] iv = new byte[IV_LENGTH];</b>
<b class="fc">&nbsp;            buffer.get(salt);</b>
<b class="fc">&nbsp;            buffer.get(iv);</b>
<b class="fc">&nbsp;            byte[] encryptedBytes = new byte[buffer.remaining()];</b>
<b class="fc">&nbsp;            buffer.get(encryptedBytes);</b>
&nbsp;
<b class="fc">&nbsp;            SecretKey secretKey = deriveKeyFromPassword(password, salt);</b>
<b class="fc">&nbsp;            Cipher cipher = Cipher.getInstance(AES_ALGORITHM);</b>
<b class="fc">&nbsp;            cipher.init(Cipher.DECRYPT_MODE, secretKey, new IvParameterSpec(iv));</b>
<b class="fc">&nbsp;            byte[] decryptedBytes = cipher.doFinal(encryptedBytes);</b>
&nbsp;
<b class="fc">&nbsp;            return new String(decryptedBytes, StandardCharsets.UTF_8);</b>
&nbsp;        } catch (Exception e) {
<b class="nc">&nbsp;            log.error(&quot;Failed to decrypt private key with password&quot;, e);</b>
<b class="nc">&nbsp;            throw new RuntimeException(&quot;Failed to decrypt private key&quot;, e);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Derive AES key from password using PBKDF2 with a random salt
&nbsp;     */
&nbsp;    private SecretKey deriveKeyFromPassword(String password, byte[] salt) throws Exception {
<b class="fc">&nbsp;        PBEKeySpec spec = new PBEKeySpec(password.toCharArray(), salt, ITERATION_COUNT, AES_KEY_SIZE);</b>
<b class="fc">&nbsp;        SecretKeyFactory factory = SecretKeyFactory.getInstance(&quot;PBKDF2WithHmacSHA256&quot;);</b>
<b class="fc">&nbsp;        byte[] keyBytes = factory.generateSecret(spec).getEncoded();</b>
<b class="fc">&nbsp;        spec.clearPassword(); // Clear sensitive data</b>
<b class="fc">&nbsp;        return new SecretKeySpec(keyBytes, &quot;AES&quot;);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Generate cryptographically secure random bytes
&nbsp;     */
&nbsp;    private byte[] generateRandomBytes(int length) {
<b class="fc">&nbsp;        byte[] bytes = new byte[length];</b>
<b class="fc">&nbsp;        SecureRandom secureRandom = new SecureRandom();</b>
<b class="fc">&nbsp;        secureRandom.nextBytes(bytes);</b>
<b class="fc">&nbsp;        return bytes;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Convert byte array to hexadecimal string
&nbsp;     */
&nbsp;    private String bytesToHex(byte[] bytes) {
<b class="fc">&nbsp;        StringBuilder hexString = new StringBuilder();</b>
<b class="fc">&nbsp;        for (byte b : bytes) {</b>
<b class="fc">&nbsp;            String hex = Integer.toHexString(0xff &amp; b);</b>
<b class="fc">&nbsp;            if (hex.length() == 1) {</b>
<b class="fc">&nbsp;                hexString.append(&#39;0&#39;);</b>
&nbsp;            }
<b class="fc">&nbsp;            hexString.append(hex);</b>
&nbsp;        }
<b class="fc">&nbsp;        return hexString.toString();</b>
&nbsp;    }
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2025-12-25 22:18</div>
</div>
</body>
</html>
